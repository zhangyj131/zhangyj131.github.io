<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    zhangyj Blog
  </title>
  <meta name="description" content="My Blog Description">
  
  <meta name="keywords" content="
  
  ">
  
  <meta name="author" content="zhangyj">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
<meta name="generator" content="Hexo 5.4.1"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220327204436.bmp"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 5 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 2 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 2 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">zhangyj Blog</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    zhangyj

    <span class="post-date float-right" title="{{moment(1648487082902).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1648487082902).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>Untitle</h1>
    <h2 id="问题描述-amp-模拟"><a href="#问题描述-amp-模拟" class="headerlink" title="问题描述&amp;模拟"></a>问题描述&amp;模拟</h2><p>线上登录接口，通过监控查看，有类型转换异常，具体报错如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220108220128.png" alt="image-20220108220128374"></p>
<p>此报错信息是dubbo consumer端显示，且登录大部分是正常，有少量部分会报类型转换异常，同事通过更换方法名+显示指定序列化id解决此问题，但是产生这个问题的真正原因是什么呢？没有指定序列化id吗？还是dubbo方法重载问题？为什么服务端不显示此错误信息呢？，下面根据错误模拟下情况。</p>
<p>线上运行情况说明，报错的这台客户端部署在容器内，jdk版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220108220823.png" alt="image-20220108220823552"></p>
<p>服务方是混跑，有虚拟机和容器，容器的jdk版本相同，虚拟机jdk版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220108220912.png" alt="image-20220108220912474"></p>
<p>一开始认为是由于没有显示指定序列化id导致容器调用虚拟机的服务，由于jvm版本不一致导致的解码问题，但是分析和试验后，发现并非如此，模拟情况如下：</p>
<p>定义一个dubbo服务，方法重载且入参不显示指定序列化id，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义dubbo服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">	Result&lt;ProductVO&gt; <span class="title function_">findProduct</span><span class="params">(String data)</span>;</span><br><span class="line">	Result&lt;ProductVO&gt; <span class="title function_">findProduct</span><span class="params">(ProductDTO product)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入参</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductDTO</span>  <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//不显示指定序列化id</span></span><br><span class="line">	<span class="keyword">private</span> Integer productId;</span><br><span class="line">	<span class="keyword">private</span> String sn;</span><br><span class="line">	<span class="keyword">private</span> String code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出参</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductVO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4529782262922750326L</span>;</span><br><span class="line">	<span class="keyword">private</span> Integer productId;</span><br><span class="line">	<span class="keyword">private</span> String productName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dubbo客户端调用<code>ProductService.findProduct(ProductDTO product)</code>，并使用jdk1.8.0_202版本，服务方使用jdk1.8.0_73版本，经过试验（jmeter压测），发现并未出现类型转换异常，现在通过代码分析来排除。</p>
<h2 id="分析-amp-dubbo-provider处理请求流程"><a href="#分析-amp-dubbo-provider处理请求流程" class="headerlink" title="分析&amp;dubbo provider处理请求流程"></a>分析&amp;dubbo provider处理请求流程</h2><p>采用逆序方法，使用arthas进行反编译dubbo生成的代理类，ProductService生成的代理类是Wrapper2，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeMethod</span><span class="params">(Object object, String name, Class[] classArray, Object[] objectArray)</span></span><br><span class="line">			<span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line">		ProductService productService;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			productService = (ProductService) object;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;findProduct&quot;</span>.equals(name) &amp;&amp; classArray.length == <span class="number">1</span></span><br><span class="line">					&amp;&amp; classArray[<span class="number">0</span>].getName().equals(<span class="string">&quot;java.lang.String&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> productService.findProduct((String) objectArray[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;findProduct&quot;</span>.equals(name) &amp;&amp; classArray.length == <span class="number">1</span></span><br><span class="line">					&amp;&amp; classArray[<span class="number">0</span>].getName().equals(<span class="string">&quot;org.pangu.dto.ProductDTO&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> productService.findProduct((ProductDTO) objectArray[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvocationTargetException</span>(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(<span class="string">&quot;Not found method \&quot;&quot;</span>).append(name)</span><br><span class="line">				.append(<span class="string">&quot;\&quot; in class org.pangu.api.ProductService.&quot;</span>).toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看反编译后的代码，得知dubbo方法重载，会根据方法类型和参数个数找到对应的目标方法执行。对于我这个线上问题，参数是ProductDTO，如果调用的是findProduct(String data)，说明classArray[0]即参数类型是String类型，那么参数类型是如何得来的呢？根据自己之前写的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangyjblogs/p/15004286.html">dubbo流程分析</a>，查看源码，在<code>com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker#invoke(Invocation invocation)</code>，代码内容如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220108223057.png" alt="image-20220108223056936"></p>
<p>方法名称+方法类型+方面参数都封装在Invocation内，接着查找Invocation的来源，在DubboProtocol的匿名内部类DubboProtocol$1内发现，具体是<code>reply(ExchangeChannel channel, Object message)</code>方法内，参数message就是Invocation。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220108225859.png" alt="image-20220108225859703"></p>
<p>接着看哪里调用<code>DubboProtocol$1.reply(ExchangeChannel channel, Object message)</code>方法，在<code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#handleRequest(ExchangeChannel channel, Request req)</code>方法内，<code>com.alibaba.dubbo.remoting.exchange.Request.getData()</code>获取此Invocation，即DecodeableRpcInvocation，那么接着看Request 以及Request.mData的来源；</p>
<p>接着向上找，在<code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#received(Channel channel, Object message)</code>的入参message就是Request ；</p>
<p>继续向上找，<code>com.alibaba.dubbo.remoting.transport.DecodeHandler#received(Channel channel, Object message)</code>的入参就是Request ，其中会对Request.mData即Invocation进行解码(默认在IO线程已经解码过，这里实际并不会再执行解码DecodeableRpcInvocation#hasDecoded&#x3D;true)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220108230753.png" alt="image-20220108230753355"></p>
<p>继续向上找，<code>com.alibaba.dubbo.remoting.transport.dispatcher.ChannelEventRunnable#run()</code>线程，message属性就是Request，那么接着只能找ChannelEventRunnable是如何创建并提交的</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220108230921.png" alt="image-20220108230921910"></p>
<p>继续向上找，在<code>com.alibaba.dubbo.remoting.transport.dispatcher.all.AllChannelHandler#received(Channel channel, Object message)</code>方法内创建ChannelEventRunnable并提交到线程池执行。</p>
<p>继续向上找，在<code>com.alibaba.dubbo.remoting.exchange.support.header.HeartbeatHandler.received(Channel channel, Object message)</code>，入参message就是Request</p>
<p>继续向上找，<code>com.alibaba.dubbo.remoting.transport.MultiMessageHandler.received(Channel channel, Object message)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220109003231.png" alt="image-20220109003230986"></p>
<p>继续向上找，<code>com.alibaba.dubbo.remoting.transport.AbstractPeer.received(Channel ch, Object msg)</code></p>
<p>继续向上找，<code>com.alibaba.dubbo.remoting.transport.netty4.NettyServerHandler.channelRead(ChannelHandlerContext ctx, Object msg)</code>，看到这个就说明是netty的work线程，NettyServerHandler是个inbound &amp; outbound事件</p>
<p>dubbo service netty启动添加的inbound&amp;outbound即pipeline chain<code>[HeadContext InternalDecoder InternalEncoder NettyServerHandler TailContext]</code>，说明前面肯定有执行InternalDecoder 的channelRead事件。此时入参message就是Request。</p>
<p>下面着重分析InternalDecoder 的channelRead事件，执行堆栈依次为：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InternalDecoder(io.netty.handler.codec.ByteToMessageDecoder).channelRead(ChannelHandlerContext ctx, Object msg)</span><br><span class="line">InternalDecoder(io.netty.handler.codec.ByteToMessageDecoder).callDecode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span><br><span class="line">InternalDecoder.decode(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out)</span><br><span class="line">DubboCountCodec.decode(Channel channel, ChannelBuffer buffer)</span><br><span class="line">DubboCodec(ExchangeCodec).decode(Channel channel, ChannelBuffer buffer)</span><br><span class="line">DubboCodec(ExchangeCodec).decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header)</span><br><span class="line">DubboCodec.decodeBody(Channel channel, InputStream is, byte[] header)</span><br><span class="line">DecodeableRpcInvocation.decode()</span><br><span class="line">DecodeableRpcInvocation.decode(Channel channel, InputStream input)</span><br></pre></td></tr></table></figure>

<p>InternalDecoder是netty pipeline的inboud事件，执行的是channelRead，具体逻辑在<code>InternalDecoder.decode(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out)</code>内，代码如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220109010146.png" alt="image-20220109010146098"></p>
<p>接着触发下一个inbound的channelRead动作，传入的就是Request了，代码说明如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220109010535.png" alt="image-20220109010534969"></p>
<p>接着看<code>DubboCountCodec.decode(Channel channel, ChannelBuffer buffer)</code>，这里进行解码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec#decode(Channel channel, ChannelBuffer buffer)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">save</span> <span class="operator">=</span> buffer.readerIndex();<span class="comment">//获取读位置</span></span><br><span class="line">    <span class="type">MultiMessage</span> <span class="variable">result</span> <span class="operator">=</span> MultiMessage.create();<span class="comment">//MultiMessage是Request的集合</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> codec.decode(channel, buffer);<span class="comment">//使用DubboCodec进行解码，下面根据解码结果进行不同处理</span></span><br><span class="line">        <span class="keyword">if</span> (Codec2.DecodeResult.NEED_MORE_INPUT == obj) &#123;<span class="comment">//说明发生了tcp粘包，退出循环</span></span><br><span class="line">            buffer.readerIndex(save);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.addMessage(obj);<span class="comment">//把obj即Request添加到集合MultiMessage</span></span><br><span class="line">            logMessageLength(obj, buffer.readerIndex() - save);</span><br><span class="line">            save = buffer.readerIndex();<span class="comment">//设置新的buffer读位置，继续使用DubboCodec进行解码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Codec2.DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.size() == <span class="number">1</span>) &#123;<span class="comment">//如果MultiMessage只有一个元素，则说明本次没有发生粘包</span></span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="number">0</span>);<span class="comment">//返回Request</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//返回MultiMessage,在后续的MultiMessagehandler内获取Request的集合遍历处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看DubboCodec(ExchangeCodec).decode(Channel channel, ChannelBuffer buffer)解码过程，如何对dubbo协议解码的，先看下dubbo协议的报文结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220109014234.png" alt="    "></p>
<p>接着看代码，对着报文结构进行解码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DubboCodec(ExchangeCodec).decode(Channel channel, ChannelBuffer buffer)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readable</span> <span class="operator">=</span> buffer.readableBytes();</span><br><span class="line">    <span class="type">byte</span>[] header = <span class="keyword">new</span> <span class="title class_">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">    buffer.readBytes(header);<span class="comment">//把缓冲区字节存放到header</span></span><br><span class="line">    <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DubboCodec(ExchangeCodec).decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="type">int</span> readable, <span class="type">byte</span>[] header)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// check magic number.</span></span><br><span class="line">    <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH</span><br><span class="line">        || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) &#123;<span class="comment">//非魔数，说明非dubbo报文的开头，说明发生了tcp拆包/粘包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> header.length;</span><br><span class="line">        <span class="keyword">if</span> (header.length &lt; readable) &#123;</span><br><span class="line">            header = Bytes.copyOf(header, readable);</span><br><span class="line">            buffer.readBytes(header, length, readable - length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) &#123;</span><br><span class="line">                buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br><span class="line">                header = Bytes.copyOf(header, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.decode(channel, buffer, readable, header);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length.</span></span><br><span class="line">    <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;<span class="comment">//为什么是小于16呢？因为dubbo报文 magic(2)+falg(1)+status(1)+invokerId(8)+bodyLenght(4)就是16字节了，小于16字节，肯定发生了拆包，本次接收到的数据并没有body</span></span><br><span class="line">        <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get data length.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Bytes.bytes2int(header, <span class="number">12</span>);<span class="comment">//12的原因是dubbo报文 magic(2)+falg(1)+status(1)+invokerId(8)等于12，从12位后取4位，转换为int，就是body的长度</span></span><br><span class="line">    checkPayload(channel, len);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">tt</span> <span class="operator">=</span> len + HEADER_LENGTH;</span><br><span class="line">    <span class="keyword">if</span> (readable &lt; tt) &#123;<span class="comment">//可读取数少于bodylen+16，说明tcp拆包，需要继续进网络读取</span></span><br><span class="line">        <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit input stream.</span></span><br><span class="line">    <span class="type">ChannelBufferInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelBufferInputStream</span>(buffer, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeBody(channel, is, header);<span class="comment">//解码body内容</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;Skip input stream &quot;</span> + is.available());</span><br><span class="line">                &#125;</span><br><span class="line">                StreamUtils.skipUnusedStream(is);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看解码dubbo body，在<code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#decodeBody</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#decodeBody(Channel channel, InputStream is, byte[] header)</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="type">byte</span>[] header)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">flag</span> <span class="operator">=</span> header[<span class="number">2</span>], proto = (<span class="type">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">    <span class="comment">// get request id.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;<span class="comment">//是响应，编码</span></span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//请求，解码</span></span><br><span class="line">        <span class="comment">// decode request.</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(id);</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object data;</span><br><span class="line">            <span class="keyword">if</span> (req.isHeartbeat()) &#123;<span class="comment">//心跳</span></span><br><span class="line">                data = decodeHeartbeatData(channel, CodecSupport.deserialize(channel.getUrl(), is, proto));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.isEvent()) &#123;<span class="comment">//事件</span></span><br><span class="line">                data = decodeEventData(channel, CodecSupport.deserialize(channel.getUrl(), is, proto));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DecodeableRpcInvocation inv;</span><br><span class="line">                <span class="keyword">if</span> (channel.getUrl().getParameter(</span><br><span class="line">                    Constants.DECODE_IN_IO_THREAD_KEY,</span><br><span class="line">                    Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;<span class="comment">//默认是在netty work线程进行解码</span></span><br><span class="line">                    inv = <span class="keyword">new</span> <span class="title class_">DecodeableRpcInvocation</span>(channel, req, is, proto);</span><br><span class="line">                    inv.decode();<span class="comment">//解码dubbo body，解码结果保存在DecodeableRpcInvocation</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    inv = <span class="keyword">new</span> <span class="title class_">DecodeableRpcInvocation</span>(channel, req,</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">UnsafeByteArrayInputStream</span>(readMessageData(is)), proto);<span class="comment">//否则在业务线程ChannelEventRunnable进行解码</span></span><br><span class="line">                &#125;</span><br><span class="line">                data = inv;</span><br><span class="line">            &#125;</span><br><span class="line">            req.setData(data);<span class="comment">//把Invocation保存到Request.mData</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Decode request failed: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// bad request</span></span><br><span class="line">            req.setBroken(<span class="literal">true</span>);</span><br><span class="line">            req.setData(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看DecodeableRpcInvocation解码dubbo body</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation#decode()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="literal">null</span> &amp;&amp; inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            decode(channel, inputStream);<span class="comment">//解码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Decode rpc invocation failed: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            request.setBroken(<span class="literal">true</span>);</span><br><span class="line">            request.setData(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            hasDecoded = <span class="literal">true</span>;<span class="comment">//解码后置位已经解码，这样在ChannelEventRunnable线程内就不会再进行解码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation#decode(com.alibaba.dubbo.remoting.Channel, java.io.InputStream)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">        .deserialize(channel.getUrl(), input);<span class="comment">//根据序列化标识获取反序列对象，dubbo spi的自适应</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">dubboVersion</span> <span class="operator">=</span> in.readUTF();<span class="comment">//从输入流读取dubbo version</span></span><br><span class="line">    request.setVersion(dubboVersion);</span><br><span class="line">    setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line"></span><br><span class="line">    setAttachment(Constants.PATH_KEY, in.readUTF());<span class="comment">//从输入流读path</span></span><br><span class="line">    setAttachment(Constants.VERSION_KEY, in.readUTF());<span class="comment">//从输入流读版本</span></span><br><span class="line"></span><br><span class="line">    setMethodName(in.readUTF());<span class="comment">//从输入流读 调用的目标方法名</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] args;</span><br><span class="line">        Class&lt;?&gt;[] pts;</span><br><span class="line">        <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> in.readUTF();<span class="comment">//从输入流读 参数描述符，即参数的类型 比如[Ljava/lang/String</span></span><br><span class="line">        <span class="keyword">if</span> (desc.length() == <span class="number">0</span>) &#123;<span class="comment">//dubbo调用方法不存在入参</span></span><br><span class="line">            pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">            args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//dubbo调用方法存在入参</span></span><br><span class="line">            pts = ReflectUtils.desc2classArray(desc);<span class="comment">//类型描述符转换为类型，比如[Ljava/lang/String =&gt; Ljava.lang.String</span></span><br><span class="line">            args = <span class="keyword">new</span> <span class="title class_">Object</span>[pts.length];<span class="comment">//参数长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    args[i] = in.readObject(pts[i]);<span class="comment">//从输入流读取参数，这里是readObject，执行反序列化</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;Decode argument failed: &quot;</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setParameterTypes(pts);<span class="comment">//把参数类型保存到Invocation对象，即parameterTypes属性上</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);<span class="comment">//从输入流读取隐式参数并解码</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Map&lt;String, String&gt; attachment = getAttachments();</span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="literal">null</span>) &#123;</span><br><span class="line">                attachment = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            attachment.putAll(map);</span><br><span class="line">            setAttachments(attachment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//decode argument ,may be callback</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = decodeInvocationArgument(channel, <span class="built_in">this</span>, pts, i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setArguments(args);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(StringUtils.toString(<span class="string">&quot;Read invocation data failed.&quot;</span>, e));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从解码dubbo body看出，从输入流解码获取调用的目标方法名称、方法类型、方法入参、隐式参数都保存到Invocation对象（即DecodeableRpcInvocation），其中读取入参和隐式参数使用到了序列化解码（需要使用到序列化id），而从输入流获取方法名称+参数类型并没有使用对象的反序列化。</p>
<h2 id="dubbo-provider处理接收总结"><a href="#dubbo-provider处理接收总结" class="headerlink" title="dubbo provider处理接收总结"></a>dubbo provider处理接收总结</h2><p>dubbo prodiver端从网络到dubbo业务线程池调用以及如何解码流程分析完，现在总结下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220109225136.png" alt="image-20220109225136447"></p>
<p>dubbo provider接收并处理consumer请求分两步</p>
<p>1.网络通信，在io线程上解码，解码结果保存到Request。</p>
<p>2.IO线程调起dubbo业务线程，传入解码结果Request，通过Invoker调用目标方法，传入要执行目标方法的对象、方法名、参数类型、参数进行调用目标方法。</p>
<h2 id="该问题分析"><a href="#该问题分析" class="headerlink" title="该问题分析"></a>该问题分析</h2><p>解决2个问题</p>
<p>问题1：为什么在服务端报错ClassCastException，在服务端没有任何error日志呢？只有在客户端才有error日志</p>
<p>由于在dubbo代理类Wrapper2调用目标方法导致ClassCastException，异常被捕捉封装为InvocationTargetException向上抛，接着在<code>com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker#invoke</code>内异常被捕捉，封装为RpcResult，继而在ExceptionFilter内异常信息被封装为RuntimeException返回客户端。这中间并没有日志打印，因此不产生error日志，所以服务端看不到。</p>
<p>问题2：dubbo方法重载会导致问题吗？</p>
<p>结论，基本不会，dubbo的动态代理类WrapperX会根据Invocation的methodName+参数类型+参数进行调用目标方法，因此不会。网上有个大佬说dubbo方法重载在某种情况会导致问题，但是他写的语句有些不通顺且凌乱，而且蓝绿是流量隔离的，不会调错，我认为他的举例不合适，感兴趣的可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/java_66666/article/details/82494448">dubbo同名方法的问题及思考</a>。</p>
<p>问题3：是否是未显式指定序列化id导致的呢？</p>
<p>经过前面分析，是由于判断参数类型是String（本来应该是DTO类型），导致执行目标方法时候把参数转换为String导致的异常，参数类型来源于Invocation对象（即RpcInvocation.parameterTypes），而Invocation来源于Request.mData，而Request是网络通信解码得来，其中在<code>com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation#decode(com.alibaba.dubbo.remoting.Channel, java.io.InputStream)</code>内<code>String desc = in.readUTF();</code>从输入流读取字节流并解码为参数类型描述符，这个地方并不涉及到对象的序列化和反序列化。</p>
<p>看客户端编码代码InternalEncoder，编码参数类型代码如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220111002311.png" alt="image-20220111002311123"></p>
<p>而客户端发送建立Request是在<code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeChannel#request(java.lang.Object, int)</code>，而Invocation对象是在dubbo调用的入口<code>InvokerInvocationHandler内(new RpcInvocation(method, args)</code>封装方法名+参数创建Invocation对象，继而参数类型就保存在了Invocation对象。</p>
<p>这样分析得来，<font color='red'>不显示指定序列化id并不会导致这个问题</font>。</p>
<p>排除了jdk版本、不显示指定序列化ID等原因，具体是什么原因导致的dubbo方法重载导致调用ClassCastException呢？线上预发环境和生产网络是互通，是否是预发环境同事手工部署的应用只有入参String的方法呢(未和生产同步版本)？同事也记不清了，也无法查，这个问题暂时是无法知道答案了。</p>
<p>据我猜测，问题可能出现是预发环境部署的服务没有和生产版本同步(缺少findProduct(ProductDTOdata)导致)，我们预发和生成网络是互通的，应该是生产客户端调用到了预发环境服务，而预发环境部署的此服务没有findProduct(ProductDTOdata)。</p>
<h2 id="为什么需要显示指定序列化id"><a href="#为什么需要显示指定序列化id" class="headerlink" title="为什么需要显示指定序列化id"></a>为什么需要显示指定序列化id</h2><p>rpc调用使用的tcp通信，需要把对象转换为二进制流进行发送（编码）和接收（解码），那么就需要有套规则需要把内存中的java对象转换为二进制流，序列化就是做这个事情的。</p>
<p>在使用原生序列化的时候，serialVersionUID起到了一个类似版本号的作用，在反序列化的时候判断serialVersionUID如果不相同，会抛出InvalidClassException。</p>
<p>如果在使用原生序列化方式的时候官方是强烈建议指定一个serialVersionUID的，如果没有指定，在序列化过程中，jvm会自动计算出一个值作为serialVersionUID，由于这种运行时计算serialVersionUID的方式依赖于jvm的实现方式，如果序列化和反序列化的jvm实现方式不一样可能会导致抛出异常InvalidClassException，所以强烈建议指定serialVersionUID。</p>
<h2 id="不显示指定序列化ID实际会导致问题吗？"><a href="#不显示指定序列化ID实际会导致问题吗？" class="headerlink" title="不显示指定序列化ID实际会导致问题吗？"></a>不显示指定序列化ID实际会导致问题吗？</h2><p>定义一个dubbo的入参，不显示指定序列化id，客户端运行不变更，服务端入参进行增加或删除字段（类结构发生变化），发现均能正常请求，并非像网上所说的不显示指定序列化id情况下rpc参数类结构变化，并没有导致什么问题，当然我只是在jdk8版本下进行了此测试(当然现在都是jdk8)，这样情况下，实际使用过程中，<font color='red'>不显示指定序列化id好像也不会影响什么呢</font>。</p>
<p>网上有说法，不显示指定序列化id会导致一种情况出现问题：举个例子：比如该入参没有显示指定序列化id，后面有个需求需要在这个入参增加个字段，而且看没有显示指定序列化id，顺手就增加了个序列化id，这样线上运行的客户端应用由于引用的还是旧jar，新的服务部署上去，就会发送序列化失败（客户端jvm生成的序列化id和服务端显示指定的序列化id不同），好像这种情况是无法避免的。但是我经过测试，不显示指定序列化id情况下 对dubbo参数进行增加字段、删除字段、增加方法等都不会造成反序列化问题(jdk8, dubbo2.6.8下测试)，请求均正常。验证结果说明<font color='red'>jvm生成序列化id和类的结构没有关系</font>。可以参考别人<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1525299">测试结果</a>，和我测试结果相同。</p>
<p>那么是否就可以大胆的不指定序列化id呢？还是建议不要，鬼知道jvm生成序列化id的实现方式呢，不指定万一线上哪天出现幺蛾子。</p>
<p>验证了半天，得到一个不指定序列化id也没关系的实际验证结论，但是又不敢完全放心大胆不显示指定序列化id，抓狂。。。</p>
<h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><p>根据实际验证(jdk8, dubbo2.6.8下测试)，<font color='red'>不显示指定序列化id时，dubbo的传输对象在增加字段、删除字段、增加方法等都不会造成反序列化问题</font>，但是还是强烈建议显示指定序列化id，万一jvm生成序列化id不兼容了呢</p>
<h2 id="该问题实际产生的猜想"><a href="#该问题实际产生的猜想" class="headerlink" title="该问题实际产生的猜想"></a>该问题实际产生的猜想</h2><p>通过自己模拟，在服务方只有findProduct(String data)的情况下(没有findProduct(ProductDTO product)方法)，那么调用肯定是ClassCastException，客户端调用异常打印</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220117224617.png" alt="image-20220117224617871"></p>
<p>和生产异常基本相同，为什么不说是ExceptionFilter的<code>return new RpcResult(new RuntimeException(StringUtils.toString(exception)));</code>，因为这样打印的日志就应该是RuntimeException了而非ClassCastException(因为在InvokerInvocationHandler执行调用，然后recreate获取客户端执行结果，有异常直接throw exception，因此判断dubbo Result的异常肯定是ClassCastException，如果是RuntimeException，打印日志应该是这样java.lang.RuntimeException: java.lang.ClassCastException: org.pangu.dto.ProductDTO cannot be cast to java.lang.String)，由此可以基本断定生产服务方某台服务部署的版本缺失入参是PdaReq的方法导致。</p>
<h2 id="以后遇到这样问题如何记录"><a href="#以后遇到这样问题如何记录" class="headerlink" title="以后遇到这样问题如何记录"></a>以后遇到这样问题如何记录</h2><p>这个问题最终没100%查出来，一来是时间稍长，当时没去排查，没记录当时的部署情况，但是，如果抛出这种异常，能否打印客户端调用的dubbo服务的ip呢？</p>
<p>服务端ExceptionFilter捕捉到异常时候把服务端的ip端口封装到异常信息内，这样客户端收到就打印异常信息就知道是哪个服务器返回的异常，需要重写dubbo默认的ExceptionFilter，同时禁用dubbo默认的ExceptionFilter，启用自定义的MyExceptionFilter不就可以了吗，在这里包装返回服务端ip即可，服务端ip从url获取。</p>
<p>步骤如下</p>
<p>步骤1：定义自定义的filter，比如MyExceptionFilter，定义代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate(group = Constants.PROVIDER, order = Integer.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">//其它代码基本和dubbo ExceptionFilter相同。不同之处看步骤5的截图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：在resources&#x2F;META-INF&#x2F;dubbo&#x2F;internal&#x2F;com.alibaba.dubbo.rpc.Filter文件内增加myexception&#x3D;org.pangu.config.MyExceptionFilter</p>
<p>步骤3：禁用dubbo ExceptionFilter，属性配置增加dubbo.provider.filter&#x3D;-exception</p>
<p>步骤四：MyExceptionFilter和dubbo ExceptionFilter的不同之处见下面代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220117232919.png" alt="image-20220117232919519"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220117233002.png" alt="image-20220117233002354"></p>
<p>增加自定义MyExceptionFilter验证这样结果，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyj131/mdpicture/docs/20220117233043.png" alt="image-20220117233043664"></p>
<p>完美。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>分析了这么长，感觉(不是100%)最终找到这个问题的产生原因，对dubbo的通信层又加深了理解，下面一篇记录下总结的dubbo通信层</p>

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="https://zhangyj131.github.io" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 zhangyj</li>
      <li><a href="https://zhangyj131.github.io">Home</a></li>
      
      <li><a target="_blank" rel="noopener" href="https://github.com/zhangyj131">Github</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a target="_blank" rel="noopener" href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a target="_blank" rel="noopener" href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
